{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/metatx/ERC2771Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (metatx/ERC2771Context.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Context variant with ERC2771 support.\n *\n * WARNING: Avoid using this pattern in contracts that rely in a specific calldata length as they'll\n * be affected by any forwarder whose `msg.data` is suffixed with the `from` address according to the ERC2771\n * specification adding the address size in bytes (20) to the calldata size. An example of an unexpected\n * behavior could be an unintended fallback (or another function) invocation while trying to invoke the `receive`\n * function only accessible if `msg.data.length == 0`.\n *\n * WARNING: The usage of `delegatecall` in this contract is dangerous and may result in context corruption.\n * Any forwarded request to this contract triggering a `delegatecall` to itself will result in an invalid {_msgSender}\n * recovery.\n */\nabstract contract ERC2771Context is Context {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable _trustedForwarder;\n\n    /**\n     * @dev Initializes the contract with a trusted forwarder, which will be able to\n     * invoke functions on this contract on behalf of other accounts.\n     *\n     * NOTE: The trusted forwarder can be replaced by overriding {trustedForwarder}.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address trustedForwarder_) {\n        _trustedForwarder = trustedForwarder_;\n    }\n\n    /**\n     * @dev Returns the address of the trusted forwarder.\n     */\n    function trustedForwarder() public view virtual returns (address) {\n        return _trustedForwarder;\n    }\n\n    /**\n     * @dev Indicates whether any particular address is the trusted forwarder.\n     */\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n        return forwarder == trustedForwarder();\n    }\n\n    /**\n     * @dev Override for `msg.sender`. Defaults to the original `msg.sender` whenever\n     * a call is not performed by the trusted forwarder or the calldata length is less than\n     * 20 bytes (an address length).\n     */\n    function _msgSender() internal view virtual override returns (address) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (isTrustedForwarder(msg.sender) && calldataLength >= contextSuffixLength) {\n            return address(bytes20(msg.data[calldataLength - contextSuffixLength:]));\n        } else {\n            return super._msgSender();\n        }\n    }\n\n    /**\n     * @dev Override for `msg.data`. Defaults to the original `msg.data` whenever\n     * a call is not performed by the trusted forwarder or the calldata length is less than\n     * 20 bytes (an address length).\n     */\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (isTrustedForwarder(msg.sender) && calldataLength >= contextSuffixLength) {\n            return msg.data[:calldataLength - contextSuffixLength];\n        } else {\n            return super._msgData();\n        }\n    }\n\n    /**\n     * @dev ERC-2771 specifies the context as being a single address (20 bytes).\n     */\n    function _contextSuffixLength() internal view virtual override returns (uint256) {\n        return 20;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/contracts/Vendor.sol": {
      "content": "//SPDX-License-Identifier: LGPL-3.0\npragma solidity 0.8.20;\n\nimport '@openzeppelin/contracts/metatx/ERC2771Context.sol';\nimport '../interfaces/IRahatProject.sol';\nimport '../interfaces/IRahatClaim.sol';\n\ncontract Vendor is ERC2771Context {\n  address public otpServerAddress;\n\n  IRahatClaim public RahatClaim;\n  IRahatProject public RahatProject;\n\n  mapping(address => mapping(address => uint)) public tokenRequestIds; //vendorAddress=>benAddress=>requestId;\n\n  constructor(\n    address _rahatProject,\n    address _rahatClaim,\n    address _forwarder,\n    address _otpServerAddress\n  ) ERC2771Context(_forwarder) {\n    RahatProject = IRahatProject(_rahatProject);\n    RahatClaim = IRahatClaim(_rahatClaim);\n    otpServerAddress = _otpServerAddress;\n  }\n\n  function requestTokenFromBeneficiary(\n    address _tokenAddress,\n    address _benAddress,\n    uint _amount\n  ) public returns (uint requestId) {\n    require(otpServerAddress != address(0), 'invalid otp-server');\n    require(\n      RahatProject.tokenAllocations(_tokenAddress, _benAddress) >= _amount,\n      'not enough balance'\n    );\n\n    requestId = RahatClaim.createClaim(\n      _msgSender(),\n      _benAddress,\n      otpServerAddress,\n      _tokenAddress,\n      _amount\n    );\n    tokenRequestIds[_msgSender()][_benAddress] = requestId;\n  }\n\n  function processTokenRequest(address _benAddress, string memory _otp) public {\n    IRahatClaim.Claim memory _claim = RahatClaim.processClaim(\n      tokenRequestIds[_msgSender()][_benAddress],\n      _otp\n    );\n    RahatProject.transferTokenToClaimer(\n      _claim.tokenAddress,\n      _claim.claimeeAddress,\n      _claim.claimerAddress,\n      _claim.amount\n    );\n  }\n}\n"
    },
    "src/interfaces/IRahatClaim.sol": {
      "content": "//SPDX-License-Identifier: LGPL-3.0\npragma solidity ^0.8.17;\n\ninterface IRahatClaim {\n  struct Claim {\n    address ownerAddress;\n    address claimerAddress;\n    address claimeeAddress;\n    address otpServerAddress;\n    address tokenAddress;\n    uint amount;\n    uint expiryDate;\n    bytes32 otpHash;\n    bool isProcessed;\n  }\n\n  function createClaim(\n    address _claimerAddress,\n    address _claimeeAddress,\n    address _otpServerAddress,\n    address _tokenAddress,\n    uint _amount\n  ) external returns (uint claimId);\n\n  function addOtpToClaim(uint _claimId, bytes32 _otpHash, uint256 _expiryDate) external;\n\n  function processClaim(uint _claimId, string memory _otp) external returns (Claim memory claim_);\n}\n"
    },
    "src/interfaces/IRahatProject.sol": {
      "content": "//SPDX-License-Identifier: LGPL-3.0\npragma solidity ^0.8.17;\n\nimport '@openzeppelin/contracts/utils/introspection/IERC165.sol';\n\ninterface IRahatProject is IERC165 {\n  function name() external view returns (string memory);\n\n  function totalAllocated() external view returns (uint256);\n\n  function tokenAllocations(\n    address _token,\n    address _address\n  ) external view returns (uint);\n\n  function transferTokenToClaimer(\n    address _tokenAddress,\n    address _benAddress,\n    address _vendorAddress,\n    uint _amount\n  ) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}